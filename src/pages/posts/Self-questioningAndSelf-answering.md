---
layout: '../../layouts/MarkdownPost.astro'
title: '自问自答'
pubDate: 1001-01-01
description: ''
author: '哈米d1ch'
cover:
    url: ''
    square: ''
    alt: 'cover'
tags: ["C", "约xxxx字 -- 阅读时间≈x分钟"]
theme: 'light'
featured: false
---

# C语言

> 定义一个数组, 再定义一个指针指向这个数组, 它们两个有什么区别?
>
> 比如, int arr[10], int* p = arr;
>
> arr 和 p 有什么区别?

1. p是一个 **指针变量**, 它的大小根据平台的不同是4位或8位, sizeof(p) == 4 或 8

    arr是一个 **数组**, 它可以表示数组首元素的**地址**, 而 **sizeof(arr) == 40 是整个数组的大小**

2. **p是一个指针变量**, **可以自增自减**, 变化的大小就是指针的类型, 而且 **可以接受其他地址的赋值 从而改变指向**, 它是可以改变的

    **arr** 表示数组首元素的 **地址**, **是一个常量**, 不仅不能通过自增自减改变, 也不能给arr本身赋值, 它是 **不可改变** 的

> 以数组的形式定义一个字符串, 和以指针的方式指向一个字符串, 它们两个有什么区别?
>
> 比如, char str1[10] = "hello"; char* str2 = "hello";
>
> str1 和 str2有什么区别?

1. str1虽然可以看作数组首元素的 **地址**, 它也可以表示一个 **数组**, sizeof(str1) == 10

    而str2只是一个指向一个字符串的 **指针**, sizeof(str2) == 4或8

2. str1数组的内容可以随意的修改, 因为它是一个数组, 用字符串来初始化, 只不过是将 **字符串的字符按照对应位置赋值给了数组**

    而str2指向的内容无法修改, 因为 **str2指向的是一个常量字符串, 常量具有常属性是不可修改的**

3. **str1** 这个表示数组首元素的 **地址, 本身无法修改**, 你 **不能 str1 = "world"**

    而 **str2** 这个指针是可以修改的, 因为它 **只是一个指针**, **修改它只是修改了它的指向**, 即 可以 str2 = "world"

> 一个被static修饰的局部变量, 与一般的局部变量有什么不同?

1. 一个 **普通的局部变量**, 其 在程序内存中的空间是位于 **栈区** 的, 这也意味着当这个局部变量出了其所在的作用域, 它的生命周期就结束了, 它在栈区中的内存空间就会被销毁

    当 **局部变量定义时被static修饰**, 那么它就不会在栈区被创建, 而是在 **全局区\静态区**, 它的 **生命周期将与程序一致**, 但 **它的作用域也仅限于定义它的作用域内**, 它的 **作用域依旧是一个普通局部变量的作用域**

2. **如果在一个会被多次调用函数中 或 循环中 定义 初始化一个静态局部变量**, 那么 **无论函数被调用多少次, 循环被执行多少次, 这个静态局部变量只会被初始化一次**

    之后的使用中, 都会以当前值使用, 而不是初始值
    
3. **当`static`修饰全局变量 或 全局函数时, 作用是 将全局变量或函数的作用域限制到当前文件内, 其他文件无法使用**

> 静态库和动态库, 有什么区别?

1. 创建方式不同

    C/C++的静态库, 是通过`ar`工具将 .c源文件编译生成的静态的与地址有关的.o目标文件 打包整合成一个静态库文件

    C/C++的动态库, 则是通过编译器, 将 .c源文件编译生成的与地址无关的.o目标文件 打包成一个动态库文件, **动态库的创建可以省略中间生成与地址无关.o文件的生成**

2. 使用方式不同

    使用静态库编译程序, 可以看作将 库文件内容完整加载到文件中 然后编译、链接生成可执行程序. 生成的可执行程序 与 直接使用源文件编译、链接生成的可执行程序 可以看作是一样的

    使用动态库编译程序, 不会将 库文件的内容完整的加载到文件中, 只会加载标识符和偏移量, 然后编译链接生成可执行程序. 生成的可执行程序, 运行时需要去找系统中的动态库文件 一起运行, 否则程序就不能运行起来, 因为无法找到动态库, 也就无法执行使用动态库接口的代码

3. 使用静态库编译生成的程序

    优点是, 不用担心系统是否拥有库文件, 可以直接运行, 因为代码是完整的. 而且, 代码都在自身, 运行速度不会打折扣

    缺点是, 生成的可执行程序体积会比较大, 毕竟是将库代码全部加载到了程序中. 而且, 如果多个程序都使用了相同的静态库, 那么是不是可以看作有冗余呢?

4. 使用动态库编译生成的程序

    优点是, 生成的可执行程序比较小, 并且, 如果多个程序使用了相同的动态库编译, 那么系统中只需要存在一个此动态库就可以 支持所有相关程序的运行

    缺点是, 程序运行时 必须要保证运行环境拥有对应的库, 其次就是, 毕竟有一部分执行代码不在进程自身内部, 所以性能可能存在折扣

> 数组初始化溢出 和 数组访问越界, 有什么区别?
>
> 数组初始化溢出: int arr[5] = { 1, 2, 3, 4, 5, 6 };
>
> 数组访问越界: arr[6] = 10;

1. 数组初始化溢出, 编译器会识别到, 可能会导致编译错误, 最少也有一定的警告

2. 数组访问越界, 编译器不会处理, 虽然这会导致一些未知行为的发生, 但是编译器不会在编译时处理

    可能会导致运行时崩溃、错误