---
layout: '../../layouts/MarkdownPost.astro'
title: '自问自答'
pubDate: 1001-01-01
description: ''
author: '哈米d1ch'
cover:
    url: ''
    square: ''
    alt: 'cover'
tags: ["C", "约xxxx字 -- 阅读时间≈x分钟"]
theme: 'light'
featured: false
---

# C语言

### 一个数组 和 指向此数组的指针的指针 有什么区别?

> 定义一个数组, 再定义一个指针指向这个数组, 它们两个有什么区别?
>
> 比如, `int arr[10], int* p = arr;`
>
> `arr`和`p`有什么区别?

1. p是一个 **指针变量**, 它的大小根据平台的不同是4位或8位, `sizeof(p) == 4 或 8`

    `arr`是一个 **数组**, 它可以表示数组首元素的**地址**, 而 **`sizeof(arr) == 40` 是整个数组的大小**

2. **`p`是一个指针变量**, **可以自增自减**, 变化的大小就是指针的类型, 而且 **可以接受其他地址的赋值 从而改变指向**, 它是可以改变的

    **`arr`** 表示数组首元素的 **地址**, **是一个常量**, 不仅不能通过自增自减改变, 也不能给`arr`本身赋值, 它是 **不可改变** 的



### 字符串数组 和 指针指向字符串 有什么区别?

> 以数组的形式定义一个字符串, 和以指针的方式指向一个字符串, 它们两个有什么区别?
>
> 比如, `char str1[10] = "hello"; char* str2 = "hello";`
>
> `str1`和`str2`有什么区别?

1. `str1`虽然可以看作数组首元素的 **地址**, 它也可以表示一个 **数组**, `sizeof(str1) == 10`

    而`str2`只是一个指向一个字符串的 **指针**, `sizeof(str2) == 4或8`

2. `str1`数组的内容可以随意的修改, 因为它是一个数组, 用字符串来初始化, 只不过是将 **字符串的字符按照对应位置赋值给了数组**

    而`str2`指向的内容无法修改, 因为 **`str2`指向的是一个常量字符串, 常量具有常属性是不可修改的**

3. **`str1`** 这个表示数组首元素的 **地址, 本身无法修改**, 你 **不能 `str1 = "world"`**

    而 **`str2`** 这个指针是可以修改的, 因为它 **只是一个指针**, **修改它只是修改了它的指向**, 即 可以 `str2 = "world"`

### `static`的作用?

> 一个被`static`修饰的局部变量, 与一般的局部变量有什么不同?

1. 一个 **普通的局部变量**, 其 在程序内存中的空间是位于 **栈区** 的, 这也意味着当这个局部变量出了其所在的作用域, 它的生命周期就结束了, 它在栈区中的内存空间就会被销毁

    当 **局部变量定义时被`static`修饰**, 那么它就不会在栈区被创建, 而是在 **全局区\静态区**, 它的 **生命周期将与程序一致**, 但 **它的作用域也仅限于定义它的作用域内**, 它的 **作用域依旧是一个普通局部变量的作用域**

2. **如果在一个会被多次调用函数中 或 循环中 定义 初始化一个静态局部变量**, 那么 **无论函数被调用多少次, 循环被执行多少次, 这个静态局部变量只会被初始化一次**

    之后的使用中, 都会以当前值使用, 而不是初始值

3. **当`static`修饰全局变量 或 全局函数时, 作用是 将全局变量或函数的作用域限制到当前文件内, 其他文件无法使用**

### C语言中, 动态库和静态库的区别?

> 静态库和动态库, 有什么区别?

1. 创建方式不同

    C/C++的静态库, 是通过`ar`工具将 .c源文件编译生成的静态的与地址有关的.o目标文件 打包整合成一个静态库文件

    C/C++的动态库, 则是通过编译器, 将 .c源文件编译生成的与地址无关的.o目标文件 打包成一个动态库文件, **动态库的创建可以省略中间生成与地址无关.o文件的生成**

2. 使用方式不同

    使用静态库编译程序, 可以看作将 库文件内容完整加载到文件中 然后编译、链接生成可执行程序. 生成的可执行程序 与 直接使用源文件编译、链接生成的可执行程序 可以看作是一样的

    使用动态库编译程序, 不会将 库文件的内容完整的加载到文件中, 只会加载标识符和偏移量, 然后编译链接生成可执行程序. 生成的可执行程序, 运行时需要去找系统中的动态库文件 一起运行, 否则程序就不能运行起来, 因为无法找到动态库, 也就无法执行使用动态库接口的代码

3. 使用静态库编译生成的程序

    优点是, 不用担心系统是否拥有库文件, 可以直接运行, 因为代码是完整的. 而且, 代码都在自身, 运行速度不会打折扣

    缺点是, 生成的可执行程序体积会比较大, 毕竟是将库代码全部加载到了程序中. 而且, 如果多个程序都使用了相同的静态库, 那么是不是可以看作有冗余呢?

4. 使用动态库编译生成的程序

    优点是, 生成的可执行程序比较小, 并且, 如果多个程序使用了相同的动态库编译, 那么系统中只需要存在一个此动态库就可以 支持所有相关程序的运行

    缺点是, 程序运行时 必须要保证运行环境拥有对应的库, 其次就是, 毕竟有一部分执行代码不在进程自身内部, 所以性能可能存在折扣

### 数组越界访问 和 数组初始化溢出, 有什么区别?

> 数组初始化溢出 和 数组访问越界, 有什么区别?
>
> 数组初始化溢出: `int arr[5] = { 1, 2, 3, 4, 5, 6 };`
>
> 数组访问越界: `arr[6] = 10;`

1. 数组初始化溢出, 编译器会识别到, 可能会导致编译错误, 最少也有一定的警告

2. 数组访问越界, 编译器不会处理, 虽然这会导致一些未知行为的发生, 但是编译器不会在编译时处理

    可能会导致运行时崩溃、错误

### 什么是大小端字节序? 如果确认一个平台的字节序?

> 如何判断一个系统的大小端存储模式?

1. 首先, 要理解大、小端字节序

2. 大端字节序: 数据的高位有效字节, 在内存中存储在 低地址处

    即, 如果存在一个4字节数据, 16进制表示为: `0x12345678`

    则 此数据的每个有效字节, 在内存中的存储位置, 从低地址到高地址为: `0x78` `0x56` `0x34` `0x12`

3. 大端字节序: 数据的高位有效字节, 在内存中存储在 高地址处

    即, 如果存在一个4字节数据, 16进制表示为: `0x12345678`

    则 此数据的每个有效字节, 在内存中的存储位置, 从低地址到高地址为: `0x12` `0x34` `0x56` `0x78`

4. 无论是大端字节序, 还是小端字节序, 都是以字节为单位的, 所以单字节内部数据顺序不能改变

5. 可以定义一个4字节数据, 然后取地址强转为单字节数据指针, 再根据指针指向的数据进行判断

    ```cpp
    #include <stdio.h>
    int main() {
        int num = 0x12345678;
        char resultPath = *(char*)&num;
        printf("0x%x\n", resultPath);
    
        if (resultPath == 0x78) {
            printf("big end \n");
        }
        else {
            printf("little end\n");
        }
    
        return 0;
    }
    ```

### 局部变量和全局变量有什么区别?

> C语言中, 局部变量和全局变量, 有什么区别?

1. 局部变量和全局变量 在内存中存储的位置不同

    局部变量一般存储在进程或线程的栈区, 而全局变量则存储在进程的全局变量区

2. 全局变量, 即使未在定义时初始化, 其默认值也是0

    局部变量, 如果在定义时未初始化, 其默认值会是随机数, 与编译器有关

3. 局部变量的作用域, 就在其被定义的作用域内

    而全局变量的作用域, 则是整个文件, 甚至如果另一个文件中`extern`了此全局变量, 在编译时 另一个文件也可以使用此全局变量

4. 局部变量因为在栈上开辟, 所以其生命周期一般就在其被定义的作用域内

    除非用`static`修饰, 被`static`修饰的局部变量的生命周期会扩大到整个进程

    全局变量, 的声明周期默认为整个进程

### 空指针 和 野指针 有什么区别?

> 什么是野指针? 空指针`NULL` 和 野指针有什么区别?

1. 野指针, 是指 指向未定义、未被进程维护的空间的指针

2. 空指针, 在C语言中是指, 被赋值为`NULL`的指针.

3. 如果代码试图访问野指针指向空间, 可能并不会发生编译时错误, 但是可能会发生运行时错误

    如果代码试图访问空指针空间, 则会发生编译时错误, 编译器会直接禁止此情况的发生

### 声明 和 定义的区别?

> 声明和定义有什么区别?

1. 声明, 并不会创建实际的变量, 更不会为其分配内存

    C语言中一般会有, 结构体类型声明、函数声明, 或者 外部变量的引用声明

    只是为了告诉编译器, 存在一个对应的标识符

2. 定义, 则是 实实在在的在内存中开辟了空间 用于存储数据的

    变量在一般情况下是不存在声明的, 因为即使 `int a`; 不进行初始化, 编译器依旧会为其分配内存

    不过, 可以使用`extern`来告诉编译器, 这个变量只是一个外部变量的引用声明, 此时编译器就不会给其分配内存空间

    此时, 如果编译的其他文件中也不存在此变量, 也就不能在后续的代码中使用变量, 编译时 会出现连接错误, 就像 声明函数但是未定义函数体内容一样

### `extern`的有什么作用?

> `extern`的作用是什么?

1. 声明外部变量 或 函数, 无法声明外部类型

    在其他文件中定义的变量或函数, 可以通过`extern`在本文件中声明并使用

    当然, 编译的时候 要与含有`extern`的变量或函数的文件一起编译

2. 声明外部变量或函数, 可以实现数据的跨文件空间

3. 与`static`刚好不同, `static`如果修饰全局变量, **会将全局变量的作用域限定在当前文件中**

    其他文件就无法通过, `extern`获得当前文件的全局变量

### `<>` 和 `""`有什么区别?

> `#include <>` 和 `#include ""` 有什么区别?

1. 使用`#include <>`包含的头文件, 编译器会去系统的相关环境变量路径中进行头文件的查找

    且, 只会在系统环境变量中的路径进行查找, 找不到就会报错

2. 使用`#include ""`一般指定路径包含头文件, 编译器会在指定路径下进行头文件的查找, 而不会去系统环境变量的路径下查找

### 传值和传地址的区别?

> 传值传参 和 传地址传参有什么区别?
>
> 如果是传值返回 和 传地址返回呢?

1. 传值传参, 一般会发生数据拷贝, 如果编译器优化则可能不会发生数据拷贝

    会创建一个临时变量, 函数体内部对形参的修改 实际 只会修改临时变量的内容, 调用函数时的原数据并不会被修改

2. 传地址传参, 不会发生数据拷贝

    会将指针直接指向传入的地址, 并不会额外开辟空间存储数据, 通过指针可以直接修改原数据的内容

3. 传值返回, 同样一般会发生数据拷贝

    编译器会将返回的数据拷贝一份存储, 直到回到调用处再将临时数据销毁

4. 传地址返回, 不会发生数据拷贝

    传地址返回需要非常的小心, 如果在 函数栈内定义了变量, 又要返回此变量的地址, 那么 返回的地址是无法正常使用的, 因为这块地址是函数栈内的局部地址已经被系统销毁

    其他情况, 返回函数内动态开辟的堆地址 或 传入的指针的地址, 都是没有问题的