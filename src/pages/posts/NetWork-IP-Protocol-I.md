---
layout: '../../layouts/MarkdownPost.astro'
title: '[TCP/IP] 网络层代表协议--IP协议介绍(1): IP协议 数据格式、... 简单介绍'
pubDate: 2024-9-04
description: ''
author: '哈米d1ch'
cover:
    url: ''
    square: ''
    alt: 'cover'
tags: ["Linux网络", "TCP-IP", "网络层", "协议", "IP", "约5755字 -- 阅读时间≈25分钟"]
theme: 'light'
featured: false
---

TCP/IP 四层协议模型, 前面的文章, 已经通过介绍具体协议了解了前两层的功能:

1. 应用层: `HTTP`和`HTTPS`

    [[TCP/IP] 初识应用层协议: 序列化与反序列化、编码与解码、jsoncpp简单食用...](https://www.humid1ch.cn/posts/NetWork-Application-Layer-Protocol)

    [[TCP/IP\] 应用层代表协议--HTTP协议 以及 HTTPS协议 分析合集](https://www.humid1ch.cn/tag/HTTP)

2. 传输层: `TCP`和`UDP`

    [[TCP/IP\] 传输层代表协议--UDP协议介绍 合集](https://www.humid1ch.cn/tags/UDP)

    [[TCP/IP\] 传输层代表协议--TCP协议介绍 合集](https://www.humid1ch.cn/tags/TCP)

本篇文章分析网络层代表协议: IP协议, **只以`ipv4`做介绍**

# `IP`协议

`TCP/IP`协议栈中:

1. 应用层:

    主要做数据的处理工作, 包括: 序列化/反序列化, 协议处理, 分析读取完整报文等

2. 传输层:

    `TCP`协议需要实现的最重要的工作是 保证数据在网络中传输的可靠性

那么网络层呢?

传输层封装的数据是要交付给网络层的, 网络层要实现的目的实际上也只有一个, 即 **让主机A 拥有能将数据 从主机A发送到主机B的能力**

网络中一定是存在多主机的, 所以数据发送到网络中以后, 一定需要能够达到目标对端主机

而, 网络层`IP`协议就可以让主机拥有这样的能力

但是, `IP`并不提供传输可靠性的保障, 数据在网络中传输的可靠性是`TCP`协议实现的, 所以 **想要数据可靠的传输到对端主机就需要结合`TCP`协议与`IP`协议**

下面就来介绍一下, `IP`协议

## `IP`协议格式

与`TCP`协议相同, `IP`协议 以`ipv4`报头的标准长度为`20`字节:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202409041757463.webp)

分析一下`ipv4`协议报头的字段:

1. `[0, 3]: 4位版本`, 用以区分`IP`协议的版本, 现在熟知的就是`ipv4`和`ipv6`, 此字段就是用来区分协议版本的

    不得不说, 协议的设计者是真的有前瞻性, 早早的就将区分版本的字段给留了出来

2. `[4, 7]: 4位首部长度`, 用于记录当前报头大小, 4位可表示`0~15`, 计算报头大小时 要*4, 所以报头大小范围为: `20~60`字节

3. `[8, 15]: 8位服务类型(TOS)`

    其中, 前三位[8, 10]为优先权字段, 但已经弃用

    [11, 14]为TOS字段, 只允许最多有一位设置为1, 分别表示: 最小延时, 最大吞吐量, 最高可靠性, 最小成本

    [15]保留字段, 没有使用

    此字段一般不需要进行设置, 除非真的有需求

4. `[16, 31]: 16位总长度(字节)`, 用于记录当前报文大小

5. `[32, 47]: 16位标识`, 起 报文分片标识作用 (后面介绍)

6. `[48, 50]: 3位标志`, 起 报文分片标志作用, 第一位保留不用 (后面介绍)

7. `[51, 63]: 13位片偏移`, 起 报文分片整理作用 (后面介绍)

8. `[64, 71]: 8位生存时间(TTL)`, 标识`IP`报文在网络中的最长生存时间

    当数据被发送到网络中之后, 数据会经过许多次的路由转发

    正常情况下, 经过许多次的路由转发, 数据可以正常的被对端主机接收到

    但是在不正常的情况下, 可能因为一些情况对端无法接收数据, 数据可能在网络中不断路由, 即 数据在网络中游离. 此时, 就需要将数据丢弃掉, 防止占用网络资源

    此字段, 即 表示数据可在网络中路由转发的最长次数

    不可过大, 不可过小

9. `[72, 79]: 8位协议`, 用于表示上层(传输层)使用协议

10. `[80, 95]: 16位首部校验和`, 用于校验协议报头是否损坏

11. `[96, 127]: 32位源IP地址`, 记录发送方主机`IP`地址, 很重要的字段

12. `[128, 159]: 32位目的IP地址`, 记录目的主机的`IP`地址, 很重要的字段

13. 至此, 一共`[0, 159]位, 20字节`, 即 `ipv4`首部标准长度为`20字节`

14. `可能: [160, ...]: 选项`, 一般情况下不会使用, 具体选项 具体分析

`TCP/IP`协议栈, 同主机不同层级之间传输数据, 存在三个操作: **封装、解包、分用**

> 关于这三个操作的概念:
>
> 1. 封装:
>
>     `TCP/IP`协议中, 当上层需要将数据发送到下层时, 就要对数据进行封装
>
>     封装, 即 在有效数据之前添加所用协议的报头
>
>     然后, 才会将封装好的数据交付给下一层
>
> 2. 解包:
>
>     在`TCP/IP`协议中, 当对端主机接收到完整数据时, 会对数据进行解包
>
>     解包, 即 对接收到的数据, 将数据中 同协议的报头部分解析并去除掉
>
>     比如, 如果传输层使用`TCP`协议发送数据, 那么接收方的传输层接收到数据之后, 会分析数据的`TCP`报头, 并将有效载荷(不包括协议报头的数据部分)提取出来
>
>     然后, 才会将有效载荷交付给上层
>
> 3. 分用:
>
>     在`TCP/IP`协议中, 当对端主机需要将数据从下层交付到上层时, 需要进行分用
>
>     分用, 即 将有效载荷交付给上层中指定的协议, 因为相同协议才能正确处理数据中的协议报头
>
>     因为, 同一层中会存在很多不同的、使用场景不同的协议, 所以需要解析出需要数据封装时所使用的协议, 才能将数据交付给上层

`IP`协议报头中:

**`[4, 7]位字段: 4位首部长度`**, 可以有效解决封装与解包的问题, 这个字段表示协议报头大小, 所以可以将数据中 协议报头有效解析出来, 进而可以解包

而 **`[72, 79]位字段: 8位协议`**, 可以有效解决分用的问题, 这个字段存储的内容是上层所使用的协议, 所以在向上层交付数据时, 读取此字段就可以解决分用问题

### `IP`协议的分片

绝大多数的字段, 简单介绍下功能就能过理解字段的实际意义

不过有几个字段需要在解释一下:

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202409051139389.webp)

这三个字段是比较重要的, 不过在解释作用之前, 要先了解一个概念: **分片**

分片, 即 如果传输层交付过来的数据较大, `IP`协议会对传输层交付过来的数据进行分割, 并 会分别对分割出来的数据进行封装. 这个行为被称为分片

为什么会进行分片呢? 

原因是, 数据链路层 因为物理设备问题, 会对数据的大小进行限制, 如果网络层交付的数据超出了限制大小, 数据链路层会直接将网络层交付的数据丢弃

所以, `IP`协议如果收到的上层数据过大, 就会对数据进行分片

而, 分片的存在就会造成一些问题: 对端主机也会收到分片, 对端主机如何确认数据是否分片? 如何确认分片数据之前是否属于同一数据? 如何确认已经完整的收到了同一数据的所有分片? 如何对已经分片的数据进行还原?

而这四个问题的答案, 都在这三个字段上

1. 对端主机 如何确认数据是否分片?

    当`IP`协议需要对数据进行分片时, 会对分片数据的`IP`协议报头的`[48, 50]: 3位标志`的对应位, 进行填充

    第`[48]`位, 保留位 不被使用

    第`[49]`位, 如果此位被设置为1, 表示禁止`IP`协议对数据分片. 此时, 当数据过大时, 将会被直接丢弃

    第`[50]`位, 用以表示 **是否有更多分片**. 当 此位被填充为1, 表示后面还有更多分片, 同时也表示当前数据为分片数据. 当此位被填充为0, 表示后面没有更多分片 或 表示此数据为非分片数据

    是否有更多分片是什么意思呢?

    当, `IP`协议对数据进行分片时, 会按照分先后顺序对数据进行分片

    如果, `IP`协议接收到6230字节的上层数据, 就会对数据进行分片, 可能会将`[0, 1023]` `[1024, 2047]` `[2048, 3071]` `[3071, 4085]` `[4096, 5119]` `[5120, 6143]` `[6144, 6229]`字节的数据, 均进行封装, 分片为个7最大不超过1500字节的`IP`数据报

    那么对于前6个分片数据, `IP`协议报头的第`[50]`位, 会被填充为1, 最后一个分片数据的 则会被填充为0

    所以, 当读取到`IP`协议报头的第`[50]`位为1时, 就说明还有属于同一数据的分片报文

2. 对端主机 如何确认分片数据 之前是否属于同一数据?

    `[32, 47] 16位标识`, 就是用来标识 分片数据原来所属的数据的

    如果, `IP`协议需要对接收到的数据进行分片, 就会将这些分片的16位标识 均填充为相同的值

    这样, 对端主机读取时, 就能够识别到分片数据 所属的原数据

3. 对端主机 如何确认已经完整的收到了同一数据的所有分片?

    首先, 对端必须接收到 报头第`[50]`位为0的分片数据

    然后就要根据`[51, 63] 13位片偏移` 确认是否有分片数据丢失了

    `[51, 63] 13位片偏移`, 填充的是 分片之后的数据首位置 相对 于原数据首位置的`偏移量/8`

    根据偏移量是否连续, 就可以确认是否完整的收到了同一数据的分片

    > 因为, [51, 63]为填充的是分片偏移量/8
    >
    > 所以, 除了最后一个分片, 前面分片的大小需要为8的倍数

4. 对端主机 如何对分片数据进行还原?

    根据`[51, 63] 13为片偏移` 进行还原 

这是`[32, 47]: 16位标识 ` `[48, 50]: 3位标志` `[51, 63]: 13位片偏移`三个字段的作用, 均与分片有关

但, 分片是一种不好的行为

因为,  `IP`协议并不能保证数据可靠性, 当对端主机 **没有收到任意一个分片数据, 就会将其他所有 所属同一数据分片全部丢弃**

这就意味着, 一旦对数据进行分片, 数据的丢包率就是所有分片丢包率的和, 即 **分别越多 丢包率越高**

所以, 一般情况下, 最好不要让`IP`协议对数据进行分片

但也不是直接禁止分片, 而是减少上层交付数据的大小, 所以 可以在传输层控制一下交付数据大小的上限

# 子网划分**

## `IP`地址

`IP`地址, 在网络中是用来确定主机的

常规情况下, 每一台接入网络的主机都需要有一个唯一的`IP`地址, 这样能够在网络中确认唯一的主机, 然后才能通过`IP`地址实现不同主机之间的通信

**`ipv4`协议的`IP`地址为4字节**, 日常通过点分十进制的方式表示, 比如: `192.168.5.111` , 点分十进制表示`IP`地址, 每个点将分隔8位数据

所以`192.168.5.111`实际表示的是 `11000000 10101000 00000101 01101111`, 刚好四个字节

**`IP`地址的这四个字节, 由两部分组成: 网络号 + 主机号. 网络号用于标识两个不同的网段, 主机号用于标识同一网段中的不同主机**

而在网络中, 不同的主机是如何通过`IP`地址来相互找到的呢?

其实, `IP`地址是被划分出来的. 既然是划分的, 那么`IP`地址的内容其实就可以表示一定的信息
